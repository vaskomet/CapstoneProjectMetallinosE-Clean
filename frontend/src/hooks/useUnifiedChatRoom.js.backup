/**
 * useUnifiedChatRoom Hook
 * 
 * Custom hook that combines UnifiedChatContext with pagination
 * for a complete chat room experience.
 * 
 * Features:
 * - Automatic room subscription/unsubscription
 * - Paginated message loading (REST API)
 * - Real-time message updates (WebSocket)
 * - Typing indicators
 * - Read receipts
 * - Message sending
 * 
 * Usage:
 * ```jsx
 * const {
 *   messages,
 *   hasMore,
 *   isLoading,
 *   loadMore,
 *   sendMessage,
 *   sendTyping,
 *   typingUsers,
 *   markAsRead
 * } = useUnifiedChatRoom(roomId);
 * ```
 */

import { useEffect, useCallback, useRef } from 'react';
import { useUnifiedChat } from '../contexts/UnifiedChatContext';
import { usePaginatedMessages } from './usePaginatedMessages';

export const useUnifiedChatRoom = (roomId, options = {}) => {
  const {
    autoSubscribe = true,
    autoMarkRead = true,
    pageSize = 50
  } = options;
  
  const {
    isConnected,
    subscribeToRoom,
    unsubscribeFromRoom,
    sendChatMessage,
    sendTyping: sendTypingIndicator,
    sendStopTyping: sendStopTypingIndicator,
    markMessagesAsRead,
    messages: contextMessages,  // Get messages object directly for reactivity
    getRoomMessages: getWebSocketMessages,
    getRoomTypingUsers,
    getRoomUnreadCount,
  } = useUnifiedChat();
  
  // Paginated messages from REST API
  const {
    messages: paginatedMessages,
    hasMore,
    isLoading,
    isLoadingMore,
    loadMore,
    addNewMessage,
    resetMessages,
  } = usePaginatedMessages(roomId, { pageSize, autoLoad: true });
  
  // Track if we've subscribed
  const isSubscribedRef = useRef(false);
  const hasReceivedWebSocketMessages = useRef(false);
  
  /**
   * Subscribe to room on mount if enabled
   */
  useEffect(() => {
    if (roomId && autoSubscribe && isConnected && !isSubscribedRef.current) {
      console.log(`ðŸ”” Auto-subscribing to room ${roomId}`);
      subscribeToRoom(roomId);
      isSubscribedRef.current = true;
    }
    
    return () => {
      if (roomId && isSubscribedRef.current) {
        console.log(`ðŸ”• Unsubscribing from room ${roomId}`);
        unsubscribeFromRoom(roomId);
        isSubscribedRef.current = false;
      }
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId, autoSubscribe, isConnected]); // Don't include subscribe/unsubscribe functions
  
  /**
   * Listen for new WebSocket messages and add to paginated list
   * This effect re-runs whenever context messages change for this room
   */
  useEffect(() => {
    if (!roomId) {
      console.log(`  â­ï¸ Skipping merge: no roomId`);
      return;
    }
    
    // Get WebSocket messages directly from contextMessages for this room
    const wsMessages = contextMessages[roomId] || [];
    
    console.log(`ðŸ” WebSocket merge effect running:`, {
      roomId,
      wsMessagesCount: wsMessages.length,
      paginatedCount: paginatedMessages.length,
      isLoading
    });
    
    // Simple logic: Add any WebSocket message that's not already in paginated messages
    if (wsMessages && wsMessages.length > 0) {
      console.log(`  âœ… Processing WebSocket messages (isLoading: ${isLoading})`);
      
      // Create a Set of existing message IDs AND temp IDs for fast lookup
      const paginatedIds = new Set();
      paginatedMessages.forEach(m => {
        paginatedIds.add(m.id); // Add real ID
        if (m._tempId) paginatedIds.add(m._tempId); // Add temp ID if exists
      });
      
      console.log(`  ðŸ“Š Paginated message IDs (last 5):`, Array.from(paginatedIds).slice(-5));
      console.log(`  ðŸ“Š WebSocket message IDs:`, wsMessages.map(m => m.id));
      
      // Filter: only include messages NOT already in paginated list
      // Check both the message ID and its temp ID (if it has one)
      const newMessages = wsMessages.filter(msg => {
        const hasSameId = paginatedIds.has(msg.id);
        const hasSameTempId = msg._tempId && paginatedIds.has(msg._tempId);
        return !hasSameId && !hasSameTempId;
      });
      
      console.log(`  ðŸ” Found ${newMessages.length} new messages to add`);
      
      if (newMessages.length > 0) {
        console.log(`ðŸ“¨ Adding ${newMessages.length} WebSocket messages to room ${roomId}:`, 
          newMessages.map(m => ({ id: m.id, tempId: m._tempId, content: m.content?.substring(0, 30) }))
        );
        newMessages.forEach(msg => addNewMessage(msg));
        hasReceivedWebSocketMessages.current = true;
      }
    } else {
      console.log(`  â­ï¸ Skipping merge: no WebSocket messages`);
    }
  }, [roomId, contextMessages, paginatedMessages, addNewMessage, isLoading]);
  
  /**
   * Auto-mark messages as read when user views them
   */
  useEffect(() => {
    if (roomId && autoMarkRead && paginatedMessages.length > 0) {
      // Get IDs of unread messages
      const unreadMessageIds = paginatedMessages
        .filter(msg => !msg.is_read)
        .map(msg => msg.id);
      
      if (unreadMessageIds.length > 0) {
        console.log(`âœ“ Auto-marking ${unreadMessageIds.length} messages as read in room ${roomId}`);
        // Small delay to ensure user has seen the messages
        const timeout = setTimeout(() => {
          markMessagesAsRead(roomId, unreadMessageIds);
        }, 1000);
        
        return () => clearTimeout(timeout);
      }
    }
  }, [roomId, autoMarkRead, paginatedMessages, markMessagesAsRead]);
  
  /**
   * Send a message
   */
  const sendMessage = useCallback((content, replyTo = null) => {
    if (!content || !content.trim()) {
      console.warn('âš ï¸ Cannot send empty message');
      return;
    }
    
    sendChatMessage(roomId, content.trim(), replyTo);
  }, [roomId, sendChatMessage]);
  
  /**
   * Send typing indicator with auto-stop after 2 seconds
   */
  const typingTimeoutRef = useRef(null);
  
  const sendTyping = useCallback(() => {
    sendTypingIndicator(roomId);
    
    // Clear existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Auto-stop after 2 seconds
    typingTimeoutRef.current = setTimeout(() => {
      sendStopTypingIndicator(roomId);
    }, 2000);
  }, [roomId, sendTypingIndicator, sendStopTypingIndicator]);
  
  /**
   * Stop typing indicator
   */
  const stopTyping = useCallback(() => {
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
      typingTimeoutRef.current = null;
    }
    sendStopTypingIndicator(roomId);
  }, [roomId, sendStopTypingIndicator]);
  
  /**
   * Mark messages as read
   */
  const markAsRead = useCallback((messageIds = []) => {
    markMessagesAsRead(roomId, messageIds);
  }, [roomId, markMessagesAsRead]);
  
  // Get current typing users
  const typingUsers = getRoomTypingUsers(roomId);
  
  // Get unread count
  const unreadCount = getRoomUnreadCount(roomId);
  
  // Cleanup typing timeout on unmount
  useEffect(() => {
    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, []);
  
  return {
    // Messages (from pagination + WebSocket)
    messages: paginatedMessages,
    hasMore,
    isLoading,
    isLoadingMore,
    loadMore,
    
    // Messaging
    sendMessage,
    isConnected,
    
    // Typing
    sendTyping,
    stopTyping,
    typingUsers,
    
    // Read receipts
    markAsRead,
    unreadCount,
    
    // Room state
    roomId,
  };
};

export default useUnifiedChatRoom;
